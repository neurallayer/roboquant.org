<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="roboquant algo-trading framework" />
    <meta name="keywords" content="trading Kotlin algo roboquant">
    <meta name="theme-color" content="#3296C8">
    <title>roboquant - Background</title>
    <!-- Favicon-->
    <link rel="icon" type="image/x-icon" href="/img/favicon.png" />
    <!-- Font awesome icons-->
    <link href="/css/asciidoctor.css" rel="stylesheet" />
    <link href="/css/rouge_github.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/v4-shims.css" />
    <!-- Core theme CSS (includes Bootstrap)-->
    <link href="/css/styles.css" rel="stylesheet" />
</head>
    <body class="d-flex flex-column">
        <main class="flex-shrink-0">
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container px-5">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                <li class="nav-item"><a class="nav-link" href="/index.html">Home</a></li>
                <li class="nav-item"><a class="nav-link" href="/documentation.html">Documentation</a></li>
                <li class="nav-item"><a class="nav-link" href="/screenshots.html">Screenshots</a></li>
                <li class="nav-item"><a class="nav-link" href="/community.html">Community</a></li>
                <li class="nav-item"><a class="nav-link" href="https://github.com/neurallayer/roboquant" target="_blank">
                    <span class="icon"><i class="fa fa-github fa-1x"></i></span> GitHub
                </a></li>
            </ul>
        </div>
    </div>
</nav>
              <header class="masthead bg-primary text-white text-center">
                     <div class="container px-5 my-1">
                         <div class="row gx-5">
                            <div class="col-lg-4 mb-5 mb-lg-0">
                            </div>
                             <div class="col-lg-8">
                                 <div class="col h-100">
                                    <h1 class="font-weight-light mt-1 doc">Background</h1>
                                 </div>
                             </div>
                         </div>
                     </div>
                 </header>

            <section class="py-5">
                <div class="container px-5 my-1">
                    <div class="row gx-5">
                        <div class="col-lg-4 mb-5 mb-lg-0">
 <h3 class="navbar-brand">Content</h3>
 <nav id="sidebar" class="navbar fixed-left sticky-top">
    <ul class="list-unstyled">
    

                 <li class="nav-item"><a href="/background/index.html" class="nav-link">Background</a></li>





















                 <li class="nav-item"><a href="/background/features.html" class="nav-link">Features</a></li>


















                 <li class="nav-item"><a href="/background/four_stages.html" class="nav-link">The 4 Stages</a></li>




    </ul>
</nav>
                         </div>
                        <div class="col-lg-8">
                            <div class="col h-100">
                                <div class="sect1">
<h2 id="_why_develop_a_new_platform">Why develop a new platform</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we started to develop <em>roboquant</em>, we looked at existing frameworks and platforms to see if these could fit the bill. However, for our use-cases none of them checked all the boxes that we required:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deal with large volumes of data and run extensive back-tests</p>
</li>
<li>
<p>Trade assets in multiple currencies at the same time</p>
</li>
<li>
<p>Support many asset classes including cryptocurrencies</p>
</li>
<li>
<p>Solid live trading, including support for advanced order types to further reduce risk</p>
</li>
<li>
<p>Support for trading in multiple markets in different regions at the same time</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some of these might be unique to our situation, but since we believe that others might profit from these features we decided to open source the platform and make it available for free.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_use_kotlin">Why use Kotlin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many computer languages available to choose from. After having developed several prototypes in different languages, we decided to go with Kotlin. Some main benefits being:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Easy to learn and use with excellent tooling support</p>
</li>
<li>
<p>It is very concise with almost no boilerplate code required</p>
</li>
<li>
<p>You can use it both within Jupyter Notebooks and traditional IDEs</p>
</li>
<li>
<p>Fast enough to even handle the largest data sets during back testing</p>
</li>
<li>
<p>Access to the huge Java ecosystem with libraries available for almost any task at hand</p>
</li>
<li>
<p>Excellent for building robust software, a necessity in our opinion when developing complex trading strategies and your own money at risk</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One often heard question is <strong>Why didn&#8217;t you choose Python instead?</strong> Truth be told, we would have loved to be able to use Python. However, during the prototype phase of <em>roboquant</em> we discovered that the performance was lacking too much for our use-cases. In some scenarios the performance was over 100x slower. This was including using libraries like Numpy and Pandas and even some Cython to speedup processing. One problem is that in back testing many things cannot be vectorized and these fast libraries like Numpy are no longer a good match.</p>
</div>
<div class="paragraph">
<p>The main reason for this lackluster performance is not only that Python is an interpreted language, but also the fact that it is has a single threaded runtime that makes it difficult and inefficient to use all the cores found on modern CPU&#8217;s.</p>
</div>
<div class="paragraph">
<p>The good news is that if you really want to stick with Python, there are plenty of alternatives available. For example, you could have a look at Backtrader, pyalgotrade or zipline. But we recommend to give <em>roboquant</em> and Kotlin a try, and we are confident you will not regret that decision.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interactive_and_traditional_development">Interactive and traditional development</h2>
<div class="sectionbody">
<div class="paragraph">
<p>From the start we developed <em>roboquant</em> to be used either as a library included in your standalone application or interactively from a Jupyter Notebook. The various APIs have been designed so that they support both use-cases equally well.</p>
</div>
<div class="paragraph">
<p>Where some Kotlin/Java based applications require a lot of ceremony to implement even the simplest piece of functionality, <em>roboquant</em> it designed to remove most of that. Especially in a Jupyter notebook environment, it is very easy to get started. Because of this the API exposed by <em>roboquant</em> follows certain rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Minimize need for imports, for example don&#8217;t expose third party types if it can be avoided</p>
</li>
<li>
<p>Use sensible defaults for method parameters where possible</p>
</li>
<li>
<p>Use informative toString() implementations and explanatory exception messages</p>
</li>
<li>
<p>Provide overloaded convenience methods if it makes life easier for the user of the API</p>
</li>
<li>
<p>Use a flat package structure, so any import is simple to remember</p>
</li>
<li>
<p>Leverage type inference where possible so no additional type info needs to be provided</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_time_handling">Time handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When testing strategies that trade simultaneously in multiple time-zones, like stocks in New York and London, it is key to have proper time management. Otherwise, you run the risk that your strategy performs very well but only because it can peep into the future due to faulty handling of time-zones.</p>
</div>
<div class="paragraph">
<p>Because of that, <em>roboquant</em> internally only uses the Java Instant type to represent a moment in time. So all time events can be easily compared without having to consider time zones.</p>
</div>
<div class="paragraph">
<p>When importing data, there is functionality to convert the data from timezone specific value towards the Instant type. When displaying time related information, it can be converted back the other way around if desired.</p>
</div>
<div class="paragraph">
<p>But the fact remains that all internal logic relies only on the Instant type in order to prevent timezone mistakes from happening.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance">Performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With data sets growing, it is important that a strategy can still be quickly evaluated and tuned when required. If this develop-test cycle becomes too slow, it is nearly impossible to create high performing strategies.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Roboquant isn&#8217;t setup to be a financial ledger and in general trading applications don&#8217;t require this accuracy. The native Java Double type provides enough precision for most algo-trading purposes and there is no need to use (the much slower and more memory hungry) BigDecimal type. The area where <em>roboquant</em> uses more precise calculation is when dealing with order and position sizes.</p>
</li>
<li>
<p>The data Feed API supports data that is kept in-memory as well data that is stored on disk and only accessed when required. This allows for running back test where the test data doesn&#8217;t fit in memory or running back-tests on machines with limited memory. In fact <em>roboquant</em> can be used on a JVM with only 512 MB of heap allocated.</p>
</li>
<li>
<p>Many of the builtin features use multithreading to speedup processing. For example the CSV parser parses CSV files in parallel so even directories with thousands of CSV files can be parsed in seconds.</p>
</li>
<li>
<p>Avoid (auto)boxing, so the JVM can access these variables directly. This means where possible use native types and not the wrapper one. See <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/language/autoboxing.html">background</a></p>
</li>
<li>
<p>Overall the latency is kept very low when processing a new event and generating a signal and order. So it is feasible to create fast, low latency (sub-second) trading strategies.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reliability">Reliability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even more important than performance, is reliability when it comes to trading software.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All components can log information that is then available for audit and tracing</p>
</li>
<li>
<p>Type and null checks where possible to leverage the compiler to identify possible mistakes</p>
</li>
<li>
<p>Extensive error logging to alert possible issues, including data quality</p>
</li>
<li>
<p>Immutable data classes (when appropriate)</p>
</li>
<li>
<p>Assert/requires to validate input parameters</p>
</li>
<li>
<p>Good unit test suite with more than 300 unit tests that covers most of the code base (&gt; 90%)</p>
</li>
<li>
<p>Proven third party libraries</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_an_event_driven_approach">Why an event-driven approach?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Event-driven software is a paradigm in which the flow of the application is determined by events such as user actions, sensor outputs, or message passing from other programs. In the case of algo-trading, these actions are often price actions that happen in the financial markets.</p>
</div>
<div class="paragraph">
<p>Event-driven algo-trading platforms provide several advantages over a vectorised approach:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reuse - <em>roboquant</em> uses the same event-driven approach for all <a href="four_stages.html">4 stages</a> of developing trading strategies, ensuring minimal friction when moving from one stage to the next.</p>
</li>
<li>
<p>Avoid Lookahead - With an event-driven test, it is unlikely that the strategy will actually peep into the future since at the time of making any decision in the code, the future data is not yet available.</p>
</li>
<li>
<p>Robustness - Live trading is by definition event-driven. So by using the same approach during back testing, it ensures you got have to address use-cases that otherwise wouldn&#8217;t show up until it is too late.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Although event-driven systems come with the above benefits, they traditionally suffer from two disadvantages over simpler vectorised systems:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>They are more complex to implement and test. That is why using platform like <em>roboquant</em> makes a lot of sense, since much of the heavy lifting is done by the platform.</p>
</li>
<li>
<p>They can be slower to execute compared to a vectorised system. But by using Kotlin and a highly optimized engine, <em>roboquant</em> is actually faster than other algo-trading platforms.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To find out more about how Events and Actions are implemented in <em>roboquant</em>, check out the documentation on <a href="../tutorial/feed.html">feeds</a>.</p>
</div>
</div>
</div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>

<footer class="bg-dark py-4 mt-auto">
    <div class="container px-5">
        <div class="row align-items-center justify-content-between flex-column flex-sm-row">
            <div class="col-auto"><div class="small m-0 text-white">Copyright &copy; roboquant.org 2021</div></div>
            <div class="col-auto">
                <a class="link-light small" href="/community.html">Contact</a>
            </div>
        </div>
    </div>
</footer>
<!-- Bootstrap core JS-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"></script>

    </body>
</html>
