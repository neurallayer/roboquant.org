= Performance
:jbake-type: doc
:icons: font
:source-highlighter: rouge
:jbake-date: 2020-01-01

When designing and developing _roboquant_, performance and scalability was one of the key objectives. The design principles that have been followed to ensure the best performance possible are:

* [x] Much of the builtin functionality uses multithreading and Kotlin coroutines to speedup processing. For example the CSVFeed parses CSV files in parallel so directories with thousands of CSV files can be parsed in seconds. So modern multicore CPU's can be fully utilized.

* [x] Roboquant is designed NOT to be a financial ledger, and in general algo-trading applications don't require this. The native Java Double type provides enough precision for algo-trading purposes and there is no need to use (the much slower and more memory hungry) BigDecimal type. BTW, the area where _roboquant_ uses high precise calculations is when dealing with order- and position-sizes.

* [x] Avoid (auto)boxing, so the JVM can access these variables directly. This means where possible use native types and not the wrapped ones. See also this https://docs.oracle.com/javase/1.5.0/docs/guide/language/autoboxing.html[autoboxing article^] from Oracle.

* [x] Optimized paths for common use-cases, like for example trading in a single currency only.

* [x] The Feed API supports data that is kept in-memory as well data that is stored on disk and only accessed when required. This allows for running back test where the test data doesn't fit in memory or running back-tests on machines with limited memory. In fact _roboquant_ can be used on a JVM with only 200 MB of heap allocated.

* [x] Avoid unnecessary copying of objects in order to limit memory allocations and garbage collection. The overall latency is kept to a minimum when processing new market data events and generating the corresponding orders. So it is feasible to create fast, low latency (millisecond) trading strategies.

* [x] Optimized collections, so they can be accessed efficiently even if back tests grow in size. For example, open- and closed-orders are maintained in two separate collections so access to open-orders is always fast.

== Performance Tests
In order to test the performance and avoid performance degradation with new releases, a standard performance test is included in the test suite. The remainder of this page provide an overview of that performance test run on different hardware. It is important to note that:

- the performance tests are designed to measure the performance of the back-test engine and not individual strategies, feeds, metrics or policies. So your performance may differ based on the used components in your back-tests.
- the used operating systems and JDKs are not further tuned and used with their out-of-the-box configuration settings.

.Running the performance test yourself
****
You can easily run the performance test on your own hardware after you've cloned the roboquant GitHub repo. All it takes is a single command from the command line:

[source, shell]
----
./mvnw test -P performance
----
****


=== Apple MacBook Pro M2
This is an Apple Silicon (ARM) based laptop with 8 CPU cores and 16GB of memory. Is has OpenJDK 19 installed. It is also the hardware used for most of the development of roboquant.

As you can see from the output below, the maximum throughput is *65 million candles per second* when running parallel back tests. For a laptop this is impressive. When you look at a single run, the performance is even more impressive. It beats powerful and much more expensive EC2 server instances by a wide margin.
----
              _______
            | $   $ |             roboquant
            |   o   |             version: 1.3.0
            |_[___]_|             build: 2023-04-03T09:39:47Z
        ___ ___|_|___ ___         os: Mac OS X 13.3
       ()___)       ()___)        home: /Users/peter/.roboquant
      // / |         | \ \\       jvm: OpenJDK 64-Bit Server VM 19.0.2
     (___) |_________| (___)      memory: 4096MB
      | |   __/___\__   | |       cpu cores: 8
      /_\  |_________|  /_\
     // \\  |||   |||  // \\
     \\ //  |||   |||  \\ //
           ()__) ()__)
           ///     \\\
        __///_     _\\\__
       |______|   |______|

*****    500.000 candlesticks *****
    feed filter               20 ms
    base run                 119 ms
    parallel runs (x8)       270 ms
    extended run             560 ms
    throughput 14 million candles/s

*****  1.000.000 candlesticks *****
    feed filter               39 ms
    base run                 172 ms
    parallel runs (x8)       390 ms
    extended run            1613 ms
    throughput 20 million candles/s

*****  5.000.000 candlesticks *****
    feed filter              189 ms
    base run                 520 ms
    parallel runs (x8)       744 ms
    extended run           14987 ms
    throughput 53 million candles/s

***** 10.000.000 candlesticks *****
    feed filter              123 ms
    base run                 705 ms
    parallel runs (x8)      1220 ms
    extended run           15689 ms
    throughput 65 million candles/s
----

=== AWS EC2 c6a.16xlarge
This is an AMD third generation Epyc processor based instance with 64 vCPU, 128GB memory and OpenJDK 17.

.Running on AWS
****
If you want to run the performance test on AWS EC2 instances, you can use the following commands to install and run the test (assuming an Ubuntu 22.04 image):

[source, shell]
----
sudo apt update
sudo apt -y install git openjdk-17-jre-headless
git clone https://github.com/neurallayer/roboquant.git
cd roboquant
./mvnw test -P performance
----
****

The maximum throughput is *82 million candles per second*, which makes it suitable for large back tests. However, given that it has 8x the number of cores compared to the Apple laptop, the performance gain is not that impressive. So it is not the most cost-efficient solution.

----
             _______
            | $   $ |             roboquant
            |   o   |             version: 1.3.0
            |_[___]_|             build: 2023-04-03T10:21:12Z
        ___ ___|_|___ ___         os: Linux 5.15.0-1031-aws
       ()___)       ()___)        home: /home/ubuntu/.roboquant
      // / |         | \ \\       jvm: OpenJDK 64-Bit Server VM 17.0.6
     (___) |_________| (___)      memory: 30688MB
      | |   __/___\__   | |       cpu cores: 64
      /_\  |_________|  /_\
     // \\  |||   |||  // \\
     \\ //  |||   |||  \\ //
           ()__) ()__)
           ///     \\\
        __///_     _\\\__
       |______|   |______|

*****    500,000 candlesticks *****
    feed filter               22 ms
    base run                 197 ms
    parallel runs (x64)      825 ms
    extended run             954 ms
    throughput 38 million candles/s

*****  1,000,000 candlesticks *****
    feed filter               24 ms
    base run                 355 ms
    parallel runs (x64)     2467 ms
    extended run            3522 ms
    throughput 25 million candles/s

*****  5,000,000 candlesticks *****
    feed filter              100 ms
    base run                1071 ms
    parallel runs (x64)     5298 ms
    extended run           21389 ms
    throughput 60 million candles/s

***** 10,000,000 candlesticks *****
    feed filter              170 ms
    base run                1180 ms
    parallel runs (x64)     7770 ms
    extended run           22232 ms
    throughput 82 million candles/s
----

=== AWS EC2 c7g.16xlarge
This is an ARM based instance (Graviton) with 64 vCPU, 128GB memory and OpenJDK 17. The hourly pricing is slightly below the AMD Epyc instance, and it has the same amount of memory and vCPU's.

You would perhaps expect that due to the long history of running server JVMs on X86 based hardware, that an ARM instance might underperform. But actually the opposite is true. The maximum throughput is *215 million candles per second*, which make it the best single instance solution for large parallel back tests.

----
            _______
            | $   $ |             roboquant
            |   o   |             version: 1.3.0
            |_[___]_|             build: 2023-04-03T10:02:44Z
        ___ ___|_|___ ___         os: Linux 5.15.0-1031-aws
       ()___)       ()___)        home: /home/ubuntu/.roboquant
      // / |         | \ \\       jvm: OpenJDK 64-Bit Server VM 17.0.6
     (___) |_________| (___)      memory: 30688MB
      | |   __/___\__   | |       cpu cores: 64
      /_\  |_________|  /_\
     // \\  |||   |||  // \\
     \\ //  |||   |||  \\ //
           ()__) ()__)
           ///     \\\
        __///_     _\\\__
       |______|   |______|

*****    500,000 candlesticks *****
    feed filter               22 ms
    base run                 182 ms
    parallel runs (x64)      537 ms
    extended run            1226 ms
    throughput 59 million candles/s

*****  1,000,000 candlesticks *****
    feed filter               30 ms
    base run                 267 ms
    parallel runs (x64)     1229 ms
    extended run            3384 ms
    throughput 52 million candles/s

*****  5,000,000 candlesticks *****
    feed filter               97 ms
    base run                 746 ms
    parallel runs (x64)     2526 ms
    extended run           16997 ms
    throughput 126 million candles/s

***** 10,000,000 candlesticks *****
    feed filter              175 ms
    base run                1052 ms
    parallel runs (x64)     2963 ms
    extended run           20695 ms
    throughput 215 million candles/s
----


=== AWS EC2 c7g.16xlarge + GraalVM
This is the same ARM based instance (Graviton) with 64 vCPU and 128GB memory. But rather than using the OpenJDK that comes with Ubuntu 22.04,  the performance tests are run using the Oracle GraalVM Enterprise 22.3.

The GraalVM based JDK was installed using the following two commands:

[source, shell]
----
bash <(curl -sL https://get.graalvm.org/ee-token)
bash <(curl -sL https://get.graalvm.org/jdk)
----

Overall the performance (*208 million candles per second*) is not significantly better than with OpenJDK. This might change in the future when GraalVM gets better optimized for the ARM CPU architecture. But for now it seems the extra hassle and cost of using GraalVM is not worth it.

----
             _______
            | $   $ |             roboquant
            |   o   |             version: 1.3.0
            |_[___]_|             build: 2023-04-03T10:32:59Z
        ___ ___|_|___ ___         os: Linux 5.15.0-1031-aws
       ()___)       ()___)        home: /home/ubuntu/.roboquant
      // / |         | \ \\       jvm: OpenJDK 64-Bit Server VM 17.0.6
     (___) |_________| (___)      memory: 30688MB
      | |   __/___\__   | |       cpu cores: 64
      /_\  |_________|  /_\
     // \\  |||   |||  // \\
     \\ //  |||   |||  \\ //
           ()__) ()__)
           ///     \\\
        __///_     _\\\__
       |______|   |______|

*****    500,000 candlesticks *****
    feed filter               27 ms
    base run                 177 ms
    parallel runs (x64)      579 ms
    extended run            1304 ms
    throughput 55 million candles/s

*****  1,000,000 candlesticks *****
    feed filter               52 ms
    base run                 309 ms
    parallel runs (x64)     1332 ms
    extended run            4809 ms
    throughput 48 million candles/s

*****  5,000,000 candlesticks *****
    feed filter              115 ms
    base run                 797 ms
    parallel runs (x64)     2687 ms
    extended run           23222 ms
    throughput 119 million candles/s

***** 10,000,000 candlesticks *****
    feed filter              178 ms
    base run                1132 ms
    parallel runs (x64)     3074 ms
    extended run           28914 ms
    throughput 208 million candles/s
----